// Generated by Ignite ignite.com/cli

import { StdFee } from "@cosmjs/launchpad";
import { SigningStargateClient, DeliverTxResponse } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgUpdateAgency } from "./types/fabchain/fab/tx";
import { MsgUpdateFilestore } from "./types/fabchain/fab/tx";
import { MsgDeletePricer } from "./types/fabchain/fab/tx";
import { MsgDeleteManufacture } from "./types/fabchain/fab/tx";
import { MsgCreatePricer } from "./types/fabchain/fab/tx";
import { MsgCreateStorefront } from "./types/fabchain/fab/tx";
import { MsgUpdatePricer } from "./types/fabchain/fab/tx";
import { MsgDeleteUser } from "./types/fabchain/fab/tx";
import { MsgUpdateProduct } from "./types/fabchain/fab/tx";
import { MsgDeleteResponse } from "./types/fabchain/fab/tx";
import { MsgUpdateStorefront } from "./types/fabchain/fab/tx";
import { MsgUpdateRequest } from "./types/fabchain/fab/tx";
import { MsgUpdateCapability } from "./types/fabchain/fab/tx";
import { MsgDeleteOrder } from "./types/fabchain/fab/tx";
import { MsgCreateUser } from "./types/fabchain/fab/tx";
import { MsgCreateProduct } from "./types/fabchain/fab/tx";
import { MsgCreateRequest } from "./types/fabchain/fab/tx";
import { MsgDeleteRequest } from "./types/fabchain/fab/tx";
import { MsgUpdateUser } from "./types/fabchain/fab/tx";
import { MsgDeleteCapability } from "./types/fabchain/fab/tx";
import { MsgCreateManufacture } from "./types/fabchain/fab/tx";
import { MsgCreateResponse } from "./types/fabchain/fab/tx";
import { MsgCreateFilestore } from "./types/fabchain/fab/tx";
import { MsgCreateOrder } from "./types/fabchain/fab/tx";
import { MsgCreateAgency } from "./types/fabchain/fab/tx";
import { MsgDeleteFilestore } from "./types/fabchain/fab/tx";
import { MsgDeleteStorefront } from "./types/fabchain/fab/tx";
import { MsgUpdateResponse } from "./types/fabchain/fab/tx";
import { MsgDeleteProduct } from "./types/fabchain/fab/tx";
import { MsgDeleteAgency } from "./types/fabchain/fab/tx";
import { MsgUpdateManufacture } from "./types/fabchain/fab/tx";
import { MsgCreateCapability } from "./types/fabchain/fab/tx";
import { MsgUpdateOrder } from "./types/fabchain/fab/tx";

import { Agency as typeAgency} from "./types"
import { EventCreateAgency as typeEventCreateAgency} from "./types"
import { Capability as typeCapability} from "./types"
import { EventCreateCapability as typeEventCreateCapability} from "./types"
import { Filestore as typeFilestore} from "./types"
import { EventCreateFilestore as typeEventCreateFilestore} from "./types"
import { Manufacture as typeManufacture} from "./types"
import { EventCreateManufacture as typeEventCreateManufacture} from "./types"
import { Order as typeOrder} from "./types"
import { Params as typeParams} from "./types"
import { Pricer as typePricer} from "./types"
import { EventCreatePricer as typeEventCreatePricer} from "./types"
import { Product as typeProduct} from "./types"
import { EventCreateProduct as typeEventCreateProduct} from "./types"
import { Request as typeRequest} from "./types"
import { EventCreateRequest as typeEventCreateRequest} from "./types"
import { Response as typeResponse} from "./types"
import { EventCreateResponse as typeEventCreateResponse} from "./types"
import { Storefront as typeStorefront} from "./types"
import { EventCreateStorefront as typeEventCreateStorefront} from "./types"
import { User as typeUser} from "./types"
import { EventCreateUser as typeEventCreateUser} from "./types"

export { MsgUpdateAgency, MsgUpdateFilestore, MsgDeletePricer, MsgDeleteManufacture, MsgCreatePricer, MsgCreateStorefront, MsgUpdatePricer, MsgDeleteUser, MsgUpdateProduct, MsgDeleteResponse, MsgUpdateStorefront, MsgUpdateRequest, MsgUpdateCapability, MsgDeleteOrder, MsgCreateUser, MsgCreateProduct, MsgCreateRequest, MsgDeleteRequest, MsgUpdateUser, MsgDeleteCapability, MsgCreateManufacture, MsgCreateResponse, MsgCreateFilestore, MsgCreateOrder, MsgCreateAgency, MsgDeleteFilestore, MsgDeleteStorefront, MsgUpdateResponse, MsgDeleteProduct, MsgDeleteAgency, MsgUpdateManufacture, MsgCreateCapability, MsgUpdateOrder };

type sendMsgUpdateAgencyParams = {
  value: MsgUpdateAgency,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateFilestoreParams = {
  value: MsgUpdateFilestore,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeletePricerParams = {
  value: MsgDeletePricer,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteManufactureParams = {
  value: MsgDeleteManufacture,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreatePricerParams = {
  value: MsgCreatePricer,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateStorefrontParams = {
  value: MsgCreateStorefront,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdatePricerParams = {
  value: MsgUpdatePricer,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteUserParams = {
  value: MsgDeleteUser,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateProductParams = {
  value: MsgUpdateProduct,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteResponseParams = {
  value: MsgDeleteResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateStorefrontParams = {
  value: MsgUpdateStorefront,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateRequestParams = {
  value: MsgUpdateRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateCapabilityParams = {
  value: MsgUpdateCapability,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteOrderParams = {
  value: MsgDeleteOrder,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateUserParams = {
  value: MsgCreateUser,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateProductParams = {
  value: MsgCreateProduct,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateRequestParams = {
  value: MsgCreateRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteRequestParams = {
  value: MsgDeleteRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateUserParams = {
  value: MsgUpdateUser,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteCapabilityParams = {
  value: MsgDeleteCapability,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateManufactureParams = {
  value: MsgCreateManufacture,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateResponseParams = {
  value: MsgCreateResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateFilestoreParams = {
  value: MsgCreateFilestore,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateOrderParams = {
  value: MsgCreateOrder,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateAgencyParams = {
  value: MsgCreateAgency,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteFilestoreParams = {
  value: MsgDeleteFilestore,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteStorefrontParams = {
  value: MsgDeleteStorefront,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateResponseParams = {
  value: MsgUpdateResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteProductParams = {
  value: MsgDeleteProduct,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteAgencyParams = {
  value: MsgDeleteAgency,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateManufactureParams = {
  value: MsgUpdateManufacture,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateCapabilityParams = {
  value: MsgCreateCapability,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateOrderParams = {
  value: MsgUpdateOrder,
  fee?: StdFee,
  memo?: string
};


type msgUpdateAgencyParams = {
  value: MsgUpdateAgency,
};

type msgUpdateFilestoreParams = {
  value: MsgUpdateFilestore,
};

type msgDeletePricerParams = {
  value: MsgDeletePricer,
};

type msgDeleteManufactureParams = {
  value: MsgDeleteManufacture,
};

type msgCreatePricerParams = {
  value: MsgCreatePricer,
};

type msgCreateStorefrontParams = {
  value: MsgCreateStorefront,
};

type msgUpdatePricerParams = {
  value: MsgUpdatePricer,
};

type msgDeleteUserParams = {
  value: MsgDeleteUser,
};

type msgUpdateProductParams = {
  value: MsgUpdateProduct,
};

type msgDeleteResponseParams = {
  value: MsgDeleteResponse,
};

type msgUpdateStorefrontParams = {
  value: MsgUpdateStorefront,
};

type msgUpdateRequestParams = {
  value: MsgUpdateRequest,
};

type msgUpdateCapabilityParams = {
  value: MsgUpdateCapability,
};

type msgDeleteOrderParams = {
  value: MsgDeleteOrder,
};

type msgCreateUserParams = {
  value: MsgCreateUser,
};

type msgCreateProductParams = {
  value: MsgCreateProduct,
};

type msgCreateRequestParams = {
  value: MsgCreateRequest,
};

type msgDeleteRequestParams = {
  value: MsgDeleteRequest,
};

type msgUpdateUserParams = {
  value: MsgUpdateUser,
};

type msgDeleteCapabilityParams = {
  value: MsgDeleteCapability,
};

type msgCreateManufactureParams = {
  value: MsgCreateManufacture,
};

type msgCreateResponseParams = {
  value: MsgCreateResponse,
};

type msgCreateFilestoreParams = {
  value: MsgCreateFilestore,
};

type msgCreateOrderParams = {
  value: MsgCreateOrder,
};

type msgCreateAgencyParams = {
  value: MsgCreateAgency,
};

type msgDeleteFilestoreParams = {
  value: MsgDeleteFilestore,
};

type msgDeleteStorefrontParams = {
  value: MsgDeleteStorefront,
};

type msgUpdateResponseParams = {
  value: MsgUpdateResponse,
};

type msgDeleteProductParams = {
  value: MsgDeleteProduct,
};

type msgDeleteAgencyParams = {
  value: MsgDeleteAgency,
};

type msgUpdateManufactureParams = {
  value: MsgUpdateManufacture,
};

type msgCreateCapabilityParams = {
  value: MsgCreateCapability,
};

type msgUpdateOrderParams = {
  value: MsgUpdateOrder,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgUpdateAgency({ value, fee, memo }: sendMsgUpdateAgencyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateAgency: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateAgency({ value: MsgUpdateAgency.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateAgency: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateFilestore({ value, fee, memo }: sendMsgUpdateFilestoreParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateFilestore: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateFilestore({ value: MsgUpdateFilestore.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateFilestore: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeletePricer({ value, fee, memo }: sendMsgDeletePricerParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeletePricer: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeletePricer({ value: MsgDeletePricer.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeletePricer: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteManufacture({ value, fee, memo }: sendMsgDeleteManufactureParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteManufacture: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteManufacture({ value: MsgDeleteManufacture.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteManufacture: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreatePricer({ value, fee, memo }: sendMsgCreatePricerParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreatePricer: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreatePricer({ value: MsgCreatePricer.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreatePricer: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateStorefront({ value, fee, memo }: sendMsgCreateStorefrontParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateStorefront: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateStorefront({ value: MsgCreateStorefront.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateStorefront: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdatePricer({ value, fee, memo }: sendMsgUpdatePricerParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdatePricer: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdatePricer({ value: MsgUpdatePricer.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdatePricer: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteUser({ value, fee, memo }: sendMsgDeleteUserParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteUser: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteUser({ value: MsgDeleteUser.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteUser: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateProduct({ value, fee, memo }: sendMsgUpdateProductParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateProduct: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateProduct({ value: MsgUpdateProduct.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateProduct: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteResponse({ value, fee, memo }: sendMsgDeleteResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteResponse({ value: MsgDeleteResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateStorefront({ value, fee, memo }: sendMsgUpdateStorefrontParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateStorefront: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateStorefront({ value: MsgUpdateStorefront.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateStorefront: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateRequest({ value, fee, memo }: sendMsgUpdateRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateRequest({ value: MsgUpdateRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateCapability({ value, fee, memo }: sendMsgUpdateCapabilityParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateCapability: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateCapability({ value: MsgUpdateCapability.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateCapability: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteOrder({ value, fee, memo }: sendMsgDeleteOrderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteOrder: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteOrder({ value: MsgDeleteOrder.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteOrder: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateUser({ value, fee, memo }: sendMsgCreateUserParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateUser: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateUser({ value: MsgCreateUser.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateUser: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateProduct({ value, fee, memo }: sendMsgCreateProductParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateProduct: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateProduct({ value: MsgCreateProduct.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateProduct: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateRequest({ value, fee, memo }: sendMsgCreateRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateRequest({ value: MsgCreateRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteRequest({ value, fee, memo }: sendMsgDeleteRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteRequest({ value: MsgDeleteRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateUser({ value, fee, memo }: sendMsgUpdateUserParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateUser: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateUser({ value: MsgUpdateUser.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateUser: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteCapability({ value, fee, memo }: sendMsgDeleteCapabilityParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteCapability: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteCapability({ value: MsgDeleteCapability.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteCapability: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateManufacture({ value, fee, memo }: sendMsgCreateManufactureParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateManufacture: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateManufacture({ value: MsgCreateManufacture.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateManufacture: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateResponse({ value, fee, memo }: sendMsgCreateResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateResponse({ value: MsgCreateResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateFilestore({ value, fee, memo }: sendMsgCreateFilestoreParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateFilestore: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateFilestore({ value: MsgCreateFilestore.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateFilestore: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateOrder({ value, fee, memo }: sendMsgCreateOrderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateOrder: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateOrder({ value: MsgCreateOrder.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateOrder: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateAgency({ value, fee, memo }: sendMsgCreateAgencyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateAgency: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateAgency({ value: MsgCreateAgency.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateAgency: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteFilestore({ value, fee, memo }: sendMsgDeleteFilestoreParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteFilestore: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteFilestore({ value: MsgDeleteFilestore.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteFilestore: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteStorefront({ value, fee, memo }: sendMsgDeleteStorefrontParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteStorefront: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteStorefront({ value: MsgDeleteStorefront.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteStorefront: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateResponse({ value, fee, memo }: sendMsgUpdateResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateResponse({ value: MsgUpdateResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteProduct({ value, fee, memo }: sendMsgDeleteProductParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteProduct: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteProduct({ value: MsgDeleteProduct.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteProduct: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteAgency({ value, fee, memo }: sendMsgDeleteAgencyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteAgency: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteAgency({ value: MsgDeleteAgency.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteAgency: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateManufacture({ value, fee, memo }: sendMsgUpdateManufactureParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateManufacture: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateManufacture({ value: MsgUpdateManufacture.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateManufacture: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateCapability({ value, fee, memo }: sendMsgCreateCapabilityParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateCapability: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateCapability({ value: MsgCreateCapability.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateCapability: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateOrder({ value, fee, memo }: sendMsgUpdateOrderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateOrder: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateOrder({ value: MsgUpdateOrder.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateOrder: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgUpdateAgency({ value }: msgUpdateAgencyParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateAgency", value: MsgUpdateAgency.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateAgency: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateFilestore({ value }: msgUpdateFilestoreParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateFilestore", value: MsgUpdateFilestore.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateFilestore: Could not create message: ' + e.message)
			}
		},
		
		msgDeletePricer({ value }: msgDeletePricerParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeletePricer", value: MsgDeletePricer.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeletePricer: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteManufacture({ value }: msgDeleteManufactureParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteManufacture", value: MsgDeleteManufacture.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteManufacture: Could not create message: ' + e.message)
			}
		},
		
		msgCreatePricer({ value }: msgCreatePricerParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreatePricer", value: MsgCreatePricer.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreatePricer: Could not create message: ' + e.message)
			}
		},
		
		msgCreateStorefront({ value }: msgCreateStorefrontParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateStorefront", value: MsgCreateStorefront.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateStorefront: Could not create message: ' + e.message)
			}
		},
		
		msgUpdatePricer({ value }: msgUpdatePricerParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdatePricer", value: MsgUpdatePricer.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdatePricer: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteUser({ value }: msgDeleteUserParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteUser", value: MsgDeleteUser.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteUser: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateProduct({ value }: msgUpdateProductParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateProduct", value: MsgUpdateProduct.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateProduct: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteResponse({ value }: msgDeleteResponseParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteResponse", value: MsgDeleteResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateStorefront({ value }: msgUpdateStorefrontParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateStorefront", value: MsgUpdateStorefront.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateStorefront: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateRequest({ value }: msgUpdateRequestParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateRequest", value: MsgUpdateRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateRequest: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateCapability({ value }: msgUpdateCapabilityParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateCapability", value: MsgUpdateCapability.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateCapability: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteOrder({ value }: msgDeleteOrderParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteOrder", value: MsgDeleteOrder.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteOrder: Could not create message: ' + e.message)
			}
		},
		
		msgCreateUser({ value }: msgCreateUserParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateUser", value: MsgCreateUser.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateUser: Could not create message: ' + e.message)
			}
		},
		
		msgCreateProduct({ value }: msgCreateProductParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateProduct", value: MsgCreateProduct.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateProduct: Could not create message: ' + e.message)
			}
		},
		
		msgCreateRequest({ value }: msgCreateRequestParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateRequest", value: MsgCreateRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateRequest: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteRequest({ value }: msgDeleteRequestParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteRequest", value: MsgDeleteRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteRequest: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateUser({ value }: msgUpdateUserParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateUser", value: MsgUpdateUser.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateUser: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteCapability({ value }: msgDeleteCapabilityParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteCapability", value: MsgDeleteCapability.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteCapability: Could not create message: ' + e.message)
			}
		},
		
		msgCreateManufacture({ value }: msgCreateManufactureParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateManufacture", value: MsgCreateManufacture.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateManufacture: Could not create message: ' + e.message)
			}
		},
		
		msgCreateResponse({ value }: msgCreateResponseParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateResponse", value: MsgCreateResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCreateFilestore({ value }: msgCreateFilestoreParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateFilestore", value: MsgCreateFilestore.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateFilestore: Could not create message: ' + e.message)
			}
		},
		
		msgCreateOrder({ value }: msgCreateOrderParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateOrder", value: MsgCreateOrder.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateOrder: Could not create message: ' + e.message)
			}
		},
		
		msgCreateAgency({ value }: msgCreateAgencyParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateAgency", value: MsgCreateAgency.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateAgency: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteFilestore({ value }: msgDeleteFilestoreParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteFilestore", value: MsgDeleteFilestore.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteFilestore: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteStorefront({ value }: msgDeleteStorefrontParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteStorefront", value: MsgDeleteStorefront.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteStorefront: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateResponse({ value }: msgUpdateResponseParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateResponse", value: MsgUpdateResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateResponse: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteProduct({ value }: msgDeleteProductParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteProduct", value: MsgDeleteProduct.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteProduct: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteAgency({ value }: msgDeleteAgencyParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgDeleteAgency", value: MsgDeleteAgency.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteAgency: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateManufacture({ value }: msgUpdateManufactureParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateManufacture", value: MsgUpdateManufacture.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateManufacture: Could not create message: ' + e.message)
			}
		},
		
		msgCreateCapability({ value }: msgCreateCapabilityParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgCreateCapability", value: MsgCreateCapability.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateCapability: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateOrder({ value }: msgUpdateOrderParams): EncodeObject {
			try {
				return { typeUrl: "/fabchain.fab.MsgUpdateOrder", value: MsgUpdateOrder.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateOrder: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						Agency: getStructure(typeAgency.fromPartial({})),
						EventCreateAgency: getStructure(typeEventCreateAgency.fromPartial({})),
						Capability: getStructure(typeCapability.fromPartial({})),
						EventCreateCapability: getStructure(typeEventCreateCapability.fromPartial({})),
						Filestore: getStructure(typeFilestore.fromPartial({})),
						EventCreateFilestore: getStructure(typeEventCreateFilestore.fromPartial({})),
						Manufacture: getStructure(typeManufacture.fromPartial({})),
						EventCreateManufacture: getStructure(typeEventCreateManufacture.fromPartial({})),
						Order: getStructure(typeOrder.fromPartial({})),
						Params: getStructure(typeParams.fromPartial({})),
						Pricer: getStructure(typePricer.fromPartial({})),
						EventCreatePricer: getStructure(typeEventCreatePricer.fromPartial({})),
						Product: getStructure(typeProduct.fromPartial({})),
						EventCreateProduct: getStructure(typeEventCreateProduct.fromPartial({})),
						Request: getStructure(typeRequest.fromPartial({})),
						EventCreateRequest: getStructure(typeEventCreateRequest.fromPartial({})),
						Response: getStructure(typeResponse.fromPartial({})),
						EventCreateResponse: getStructure(typeEventCreateResponse.fromPartial({})),
						Storefront: getStructure(typeStorefront.fromPartial({})),
						EventCreateStorefront: getStructure(typeEventCreateStorefront.fromPartial({})),
						User: getStructure(typeUser.fromPartial({})),
						EventCreateUser: getStructure(typeEventCreateUser.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const Module = (test: IgniteClient) => {
	return {
		module: {
			FabchainFab: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default Module;